#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "delay.h"
#include "ds1820.h"

#define PORT  GPIOA   //указать порт, к которому подключены датчики
#define TIMER TIM3    //задаем таймер, используемый для формирования задержек
 
//*********************************************************************************************
//function  импульс сброса                                                                   //
//argument  маска порта                                                                      //
//return    0 - устройство обнаружен, 1 - не обнаружено, 2 - к.з. на линии                   //
//*********************************************************************************************
uint8_t ds_reset_pulse(uint16_t PinMask)
{
   uint16_t result;   
 
 //  if((PORT->IDR & PinMask)==0)  return 2;         //проверить линию на отсутствие замыкания
   PORT->ODR &= ~PinMask;                          //потянуть шину к земле
   TIMER->CNT=0;
   while(TIMER->CNT<480){};                        //ждать 480 микросекунд
   PORT->ODR |=  PinMask;                          //отпустить шину
   while(TIMER->CNT<550){};                        //ждать 70 микросекунд
   result     =  PORT->IDR & PinMask;              //прочитать шину 
   while(TIMER->CNT<960){};                        //дождаться окончания инициализации
   if(result)  {
     return 1;                            //датчик не обнаружен
   }
   
   return 0;                                       //датчик обнаружен      
}

//*********************************************************************************************
//function  передача бита                                                                    //
//argument  значение передаваемого бита,маска порта                                          //
//return    none                                                                             //
//*********************************************************************************************
void ds_write_bit(uint8_t bit,uint16_t PinMask)
{
   TIMER->CNT=0;
   PORT->ODR &= ~PinMask;                          //потянуть шину к земле
   while(TIMER->CNT<2){};                          //ждать 1 микросекунду
   if(bit) PORT->ODR |=  PinMask;                  //если передаем 1, то отпускаем шину
   while(TIMER->CNT<60){};                         //задержка 60 микросекунд 
   PORT->ODR |=  PinMask;                          //отпускаем шину 
}

//*********************************************************************************************
//function  чтение бита                                                                      //
//argument  маска порта                                                                      //
//return    прочитанный бит                                                                  //
//*********************************************************************************************
uint16_t ds_read_bit(uint16_t PinMask)
{
   uint16_t result;
 
   TIMER->CNT=0;
   PORT->ODR &= ~PinMask;                          //потянуть шину к земле
   while(TIMER->CNT<2){};
   PORT->ODR |=  PinMask;                          //отпускаем шину  
   while(TIMER->CNT<15){};                         //задержка 15 микросекунд
   result     =  PORT->IDR & PinMask;              //прочитать шину
   while(TIMER->CNT<60){};                         //оставшееся время 
   return result;                                  //возвратить результат
}

//*********************************************************************************************
//function  запись байта                                                                     //
//argument  передаваемый байт,маска порта                                                    //
//return    none                                                                             //
//*********************************************************************************************
void ds_write_byte(uint8_t byte, uint16_t PinMask)
{
   uint8_t i;
   for(i=0;i<8;i++) ds_write_bit(byte&(1<<i), PinMask);
}

//*********************************************************************************************
//function  чтение байта                                                                     //
//argument  маска порта                                                                      //
//return    прочитанный байт                                                                 //
//*********************************************************************************************
uint8_t ds_read_byte(uint16_t PinMask)
{
   uint8_t i,result = 0;
   for(i=0;i<8;i++) 
   if(ds_read_bit(PinMask)) result |= 1<<i; 
   return result;
}

//*********************************************************************************************
//function  пуск измерения температуры                                                       //
//argument  номер пина порта 0..15                                                           //
//return    0 - пуск выполнен, 1 - датчик не обнаружен, 2 - к.з. на линии                    //
//*********************************************************************************************
uint8_t ds_start_convert_single(uint8_t PinNumb)
{
  uint8_t result;
  result = ds_reset_pulse(1<<PinNumb);       //послать импульс сброса
  if(result) return result;                  //если ошибка - возвращаем ее код
  ds_write_byte(0xCC,1<<PinNumb);            //разрешить доступ к датчику не используя адрес  
  ds_write_byte(0x44,1<<PinNumb);            //запустить преобразование
  return 0;
}
//*********************************************************************************************
//function  чтение памяти датчика                                                            //
//argument  указатель на массив-приемник данных, номер пина порта 0..15                      //
//return    0 - данные прочитаны, 1 - датчик не обнаружен, 2 - к.з. на линии                 //
//*********************************************************************************************
uint8_t ds_read_data_single(uint8_t *buff, uint8_t PinNumb)
{
  uint8_t result,i;
  result = ds_reset_pulse(1<<PinNumb);       //послать импульс сброса
  if(result) return result;                  //если ошибка - возвращаем ее код
  ds_write_byte(0xCC,1<<PinNumb);            //разрешить доступ к датчику не используя адрес  
  ds_write_byte(0xBE,1<<PinNumb);            //запрос 9 байт памяти
  for( i=0; i<9; i++) 
    buff[i] = ds_read_byte(1<<PinNumb);      //прочитать 9 байт
  return 0;
}

signed int ds_read_temperature(uint8_t PinNumb)
{
  signed char integer = 0;     
  signed char frac;
  signed int  result;
  uint8_t     buff[8];
 
  //прочитать данные из датчика 
  if(ds_read_data_single(&buff[0],PinNumb))  return 1280;
 
  frac    = buff[0] & 0x0f;                            //получить дробную часть      
  integer = (buff[0]>>4) | ((buff[1] & 0x0f)<<4);      //получить целую часть 
 
  //если температура отрицательная
  if(integer<0)
  {
    integer = 0 - integer - 1;
    result  = integer *10;                            //учитываем целую часть
    frac = frac | 0xf0;
    frac = 0 - frac ;                                 
  }
  //если температура положительная
  else     result  = integer *10;                    //учитываем целую часть
 
  result = result + ((frac*10)/16);                  //учитываем дробную часть
 
  return result;
}

///----------------////--------------------////
void _delay(uint32_t del)
{
	for(volatile uint32_t i = 0; i<del; i++); 
} 
 
void send_presence(uint8_t PinNumb) { 	
      GPIOA->ODR = PinNumb;
        _delay(100);
	GPIOA->ODR = 0;
	_delay(3500); //420us
	GPIOA->ODR = PinNumb;
}

void one_wire_write_bit(uint8_t bit,uint8_t PinNumb)
{
	GPIOA->ODR = 0;
	_delay(bit ? 150 : 500);
       	GPIOA->ODR = PinNumb;
	_delay(bit ? 650 : 200);
}

uint8_t one_wire_read_bit(uint8_t PinNumb)
{
	uint8_t bit = 0;
	GPIOA->ODR = 0;
	_delay(80);
	GPIOA->ODR = PinNumb;
	_delay(50);
	GPIOA->CRL &= ~GPIO_CRL_MODE3;
	GPIOA->CRL &= ~GPIO_CRL_CNF3;
	GPIOA->CRL |=  GPIO_CRL_CNF3_0;
	bit = (GPIOA->IDR&PinNumb?1:0);
	GPIOA->CRL |=  GPIO_CRL_MODE3;
	GPIOA->CRL |=  GPIO_CRL_CNF3_0;
	_delay(600);
	return bit;
}

void one_wire_write_byte(uint8_t data,uint8_t PinNumb)
{
	for(uint8_t i = 0; i<8; i++) 		one_wire_write_bit(data>>i & 1,PinNumb);
}

void ds18d20_init(uint8_t PinNumb){
  send_presence(PinNumb);
	_delay(5500);
	one_wire_write_byte(0xCC,PinNumb); // 0xCC (обращаемся к единственному устройству на линии)
	one_wire_write_byte(0x4E,PinNumb); // 0x4E (запись в регистры)
	one_wire_write_byte(0x00,PinNumb); // 0x4B (верхний порог тревоги)
	one_wire_write_byte(0x00,PinNumb); // 0x46 (нижний порог тревоги)
	//one_wire_write_byte(0x5F); // 0x5F (разрядность 11 бит)
        one_wire_write_byte(0x7F,PinNumb); // 0x7F (разрядность 12 бит)
}


void ds18d20_start(uint8_t PinNumb)
{
  
        
        send_presence(PinNumb);
	_delay(5500);
	one_wire_write_byte(0xCC,PinNumb);
	one_wire_write_byte(0x44,PinNumb);
        
 
}


float ds18d20_read(uint8_t PinNumb){

	send_presence(PinNumb);
	_delay(5500);
	one_wire_write_byte(0xCC,PinNumb);
	one_wire_write_byte(0xBE,PinNumb);
	_delay(4000);
	uint16_t data = 0;
	for(uint8_t i = 0; i<16; i++)  data += (uint16_t)one_wire_read_bit(PinNumb)<<i;
	return data/16.0;
}


//***************************************************************************
// CRC8
// Для серийного номера вызывать 8 раз
// Для данных вызвать 9 раз
// Если в результате crc == 0, то чтение успешно
//***************************************************************************
uint8_t crc8 (uint8_t data, uint8_t crc)
#define CRC8INIT   0x00
#define CRC8POLY   0x18              //0X18 = X^8+X^5+X^4+X^0
{
	uint8_t bit_counter;
	uint8_t feedback_bit;
	bit_counter = 8;
	do
	{
		feedback_bit = (crc ^ data) & 0x01;
		if ( feedback_bit == 0x01 ) crc = crc ^ CRC8POLY;
		crc = (crc >> 1) & 0x7F;
		if ( feedback_bit == 0x01 ) crc = crc | 0x80;
		data = data >> 1;
		bit_counter--;
	}  while (bit_counter > 0);
	return crc;
}


/*
int ds1820_readtemp(void)
{
	uint8_t temp1, temp2, t3;
	uint16_t temp3;

	send_presence(PinNumb);
	one_wire_write_byte(0xCC,3);
	one_wire_write_byte(0xBE,3);

        uint8_t crc = 0;
        uint8_t crc_buf[9];
        for (t3 = 0; t3 < 9; t3++)
        {
          //__disable_interrupt();
          crc_buf[t3] = one_wire_read_bit(PinNumb);
          //__enable_interrupt();
        }


        for (t3 = 0; t3 < 9; t3++)
          crc = crc8(crc_buf[t3], crc);

   //     if (crc == 0)
          temp3 = (int16_t) ((uint16_t)(crc_buf[1] * 256) + (uint16_t)crc_buf[0]);
//        else
//          temp3 = 0;
	//temp1 = onewire_read();   // D2
	//temp2 = onewire_read();  // 01
	//t3 = onewire_read();
	//t3 = onewire_read();
	//t3 = onewire_read();

	//temp3 = (uint16) temp2 * (uint16)0x0100L + (uint16) temp1;
 	//temp3 = temp3 / 16; // целочисленное деление на 16
	return temp3;
}
*/

